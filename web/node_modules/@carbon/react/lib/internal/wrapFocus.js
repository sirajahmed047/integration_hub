/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var findLast = require('lodash.findlast');
var React = require('react');
var navigation = require('./keyboard/navigation.js');
var tabbable = require('tabbable');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var findLast__default = /*#__PURE__*/_interopDefaultLegacy(findLast);

/**
 * @param {Node} node A DOM node.
 * @param {string[]} selectorsFloatingMenus The CSS selectors that matches floating menus.
 * @returns {boolean} `true` of the given `node` is in a floating menu.
 */
function elementOrParentIsFloatingMenu(node) {
  let selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (node && typeof node.closest === 'function') {
    const allSelectorsFloatingMenus = [`.cds--overflow-menu-options`, `.cds--tooltip`, '.flatpickr-calendar', ...selectorsFloatingMenus];
    return allSelectorsFloatingMenus.some(selector => node.closest(selector));
  }
}

/**
 * Ensures the focus is kept in the given `modalNode`, implementing "focus-wrap" behavior.
 * @param {object} options The options.
 * @param {Node|null} options.bodyNode
 * @param {Node|null} options.startTrapNode The DOM node of the focus sentinel the is placed earlier next to `modalNode`.
 * @param {Node|null} options.endTrapNode The DOM node of the focus sentinel the is placed next to `modalNode`.
 * @param {Node} options.currentActiveNode The DOM node that has focus.
 * @param {Node} options.oldActiveNode The DOM node that previously had focus.
 * @param {string[]} [options.selectorsFloatingMenus] The CSS selectors that matches floating menus.
 */
function wrapFocus(_ref) {
  let {
    bodyNode,
    startTrapNode,
    endTrapNode,
    currentActiveNode,
    oldActiveNode,
    selectorsFloatingMenus
  } = _ref;
  if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {
    const comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);
    if (currentActiveNode === startTrapNode || comparisonResult & navigation.DOCUMENT_POSITION_BROAD_PRECEDING) {
      const tabbable = findLast__default["default"](bodyNode.querySelectorAll(navigation.selectorTabbable), elem => Boolean(elem.offsetParent));
      if (tabbable) {
        tabbable.focus();
      } else if (bodyNode !== oldActiveNode) {
        bodyNode.focus();
      }
    } else if (currentActiveNode === endTrapNode || comparisonResult & navigation.DOCUMENT_POSITION_BROAD_FOLLOWING) {
      const tabbable = Array.prototype.find.call(bodyNode.querySelectorAll(navigation.selectorTabbable), elem => Boolean(elem.offsetParent));
      if (tabbable) {
        tabbable.focus();
      } else if (bodyNode !== oldActiveNode) {
        bodyNode.focus();
      }
    }
  }
}

/**
 * Ensures the focus is kept in the given `containerNode`, implementing "focus-wrap" behavior.
 * Note: This must be called *before* focus moves using onKeyDown or similar.
 * @param {object} options The options.
 * @param {Node|null} options.containerNode
 * @param {EventTarget} options.currentActiveNode The DOM node that has focus.
 * @param {KeyboardEvent} options.event The DOM event
 */
function wrapFocusWithoutSentinels(_ref2) {
  let {
    containerNode,
    currentActiveNode,
    event
  } = _ref2;
  if (['blur', 'focusout', 'focusin', 'focus'].includes(event.type) && process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(() => {
      throw new Error(`Error: wrapFocusWithoutSentinels(...) called in unsupported ${event.type} event.\n\nCall wrapFocusWithoutSentinels(...) from onKeyDown instead.`);
    });
  }

  // The reason we're using tabbable is because it returns the tabbable
  // items *in tab order*, whereas using our `selectorTabbable` only
  // returns in DOM order
  const tabbables = tabbable.tabbable(containerNode);
  const firstTabbable = tabbables[0];
  const lastTabbable = tabbables[tabbables.length - 1];

  // console.log(`---------------------------------`);
  // console.log(containerNode);
  // console.log(tabbables);
  // console.log(firstTabbable);
  // console.log(lastTabbable);
  // console.log(currentActiveNode);

  // The shift key is used to determine if focus is moving forwards or backwards
  if (currentActiveNode === lastTabbable && !event.shiftKey) {
    // Cancel the current movement of focus because we're going to place it ourselves
    event.preventDefault();
    firstTabbable.focus();
  }
  if (currentActiveNode === firstTabbable && event.shiftKey) {
    // Cancel the current movement of focus because we're going to place it ourselves
    event.preventDefault();
    lastTabbable.focus();
  }
}

exports["default"] = wrapFocus;
exports.elementOrParentIsFloatingMenu = elementOrParentIsFloatingMenu;
exports.wrapFocusWithoutSentinels = wrapFocusWithoutSentinels;
