/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');
var cx = require('classnames');
var Downshift = require('downshift');
var PropTypes = require('prop-types');
var React = require('react');
require('../Text/index.js');
var iconsReact = require('@carbon/icons-react');
var index = require('../ListBox/index.js');
var setupGetInstanceId = require('../../tools/setupGetInstanceId.js');
var mergeRefs = require('../../tools/mergeRefs.js');
var deprecate = require('../../prop-types/deprecate.js');
var usePrefix = require('../../internal/usePrefix.js');
require('../FluidForm/FluidForm.js');
var FormContext = require('../FluidForm/FormContext.js');
var Text = require('../Text/Text.js');
var match = require('../../internal/keyboard/match.js');
var ListBoxSelection = require('../ListBox/next/ListBoxSelection.js');
var ListBoxTrigger = require('../ListBox/next/ListBoxTrigger.js');
var ListBoxPropTypes = require('../ListBox/ListBoxPropTypes.js');
var keys = require('../../internal/keyboard/keys.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const {
  InputBlur,
  InputKeyDownEnter,
  FunctionToggleMenu,
  ToggleButtonClick,
  ItemMouseMove,
  InputKeyDownArrowUp,
  InputKeyDownArrowDown,
  MenuMouseLeave
} = Downshift.useCombobox.stateChangeTypes;
const defaultItemToString = item => {
  if (typeof item === 'string') {
    return item;
  }
  if (typeof item === 'number') {
    return `${item}`;
  }
  if (item !== null && typeof item === 'object' && 'label' in item && typeof item['label'] === 'string') {
    return item['label'];
  }
  return '';
};
const defaultShouldFilterItem = () => true;
const getInputValue = _ref => {
  let {
    initialSelectedItem,
    inputValue,
    itemToString,
    selectedItem
  } = _ref;
  if (selectedItem) {
    return itemToString(selectedItem);
  }
  if (initialSelectedItem) {
    return itemToString(initialSelectedItem);
  }
  return inputValue || '';
};
const findHighlightedIndex = (_ref2, inputValue) => {
  let {
    items,
    itemToString = defaultItemToString
  } = _ref2;
  if (!inputValue) {
    return -1;
  }
  const searchValue = inputValue.toLowerCase();
  for (let i = 0; i < items.length; i++) {
    const item = itemToString(items[i]).toLowerCase();
    if (!items[i]['disabled'] && item.indexOf(searchValue) !== -1) {
      return i;
    }
  }
  return -1;
};
const getInstanceId = setupGetInstanceId["default"]();
const ComboBox = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    ['aria-label']: ariaLabel = 'Choose an item',
    ariaLabel: deprecatedAriaLabel,
    className: containerClassName,
    direction = 'bottom',
    disabled = false,
    downshiftProps,
    helperText,
    id,
    initialSelectedItem,
    invalid,
    invalidText,
    items,
    itemToElement = null,
    itemToString = defaultItemToString,
    light,
    onChange,
    onInputChange,
    onToggleClick,
    placeholder,
    readOnly,
    selectedItem: selectedItemProp,
    shouldFilterItem = defaultShouldFilterItem,
    size,
    titleText,
    translateWithId,
    warn,
    warnText,
    allowCustomValue = false,
    slug,
    ...rest
  } = props;
  const prefix = usePrefix.usePrefix();
  const {
    isFluid
  } = React.useContext(FormContext.FormContext);
  const textInput = React.useRef(null);
  const comboBoxInstanceId = getInstanceId();
  const [inputValue, setInputValue] = React.useState(getInputValue({
    initialSelectedItem,
    inputValue: '',
    itemToString,
    selectedItem: selectedItemProp
  }));
  const [isFocused, setIsFocused] = React.useState(false);
  const [prevSelectedItem, setPrevSelectedItem] = React.useState();
  const [doneInitialSelectedItem, setDoneInitialSelectedItem] = React.useState(false);
  const savedOnInputChange = React.useRef(onInputChange);
  if (!doneInitialSelectedItem || prevSelectedItem !== selectedItemProp) {
    setDoneInitialSelectedItem(true);
    setPrevSelectedItem(selectedItemProp);
    setInputValue(getInputValue({
      initialSelectedItem,
      inputValue,
      itemToString,
      selectedItem: selectedItemProp
    }));
  }
  const filterItems = (items, itemToString, inputValue) => items.filter(item => shouldFilterItem ? shouldFilterItem({
    item,
    itemToString,
    inputValue
  }) : defaultShouldFilterItem());
  React.useEffect(() => {
    savedOnInputChange.current = onInputChange;
  }, [onInputChange]);
  React.useEffect(() => {
    if (savedOnInputChange.current) {
      savedOnInputChange.current(inputValue);
    }
  }, [inputValue]);
  const handleSelectionClear = () => {
    if (textInput?.current) {
      textInput.current.focus();
    }
  };
  const filteredItems = inputValue => filterItems(items, itemToString, inputValue || null);
  const indexToHighlight = inputValue => findHighlightedIndex({
    ...props,
    items: filteredItems(inputValue)
  }, inputValue);
  const stateReducer = React__default["default"].useCallback((state, actionAndChanges) => {
    const {
      type,
      changes
    } = actionAndChanges;
    const {
      highlightedIndex
    } = changes;
    switch (type) {
      case InputBlur:
        if (state.inputValue && highlightedIndex == '-1' && !allowCustomValue) {
          return {
            ...changes,
            inputValue: ''
          };
        }
        return changes;
      case InputKeyDownEnter:
        if (allowCustomValue) {
          setInputValue(inputValue);
          setHighlightedIndex(changes.selectedItem);
          if (onChange) {
            onChange({
              selectedItem: changes.selectedItem
            });
          }
          return changes;
        } else if (changes.selectedItem && !allowCustomValue) {
          return changes;
        } else {
          return {
            ...changes,
            isOpen: true
          };
        }
      case FunctionToggleMenu:
      case ToggleButtonClick:
        if (changes.isOpen && !changes.selectedItem) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case MenuMouseLeave:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case InputKeyDownArrowUp:
      case InputKeyDownArrowDown:
        if (highlightedIndex === -1) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case ItemMouseMove:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      default:
        return changes;
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [allowCustomValue, inputValue, onChange]);
  const handleToggleClick = isOpen => event => {
    if (onToggleClick) {
      onToggleClick(event);
    }
    if (event.target === textInput.current && isOpen) {
      event.preventDownshiftDefault = true;
      event?.persist?.();
    }
  };
  const showWarning = !invalid && warn;
  const className = cx__default["default"](`${prefix}--combo-box`, {
    [`${prefix}--list-box--up`]: direction === 'top',
    [`${prefix}--combo-box--warning`]: showWarning,
    [`${prefix}--combo-box--readonly`]: readOnly
  });
  const titleClasses = cx__default["default"](`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled
  });
  const helperTextId = `combobox-helper-text-${comboBoxInstanceId}`;
  const warnTextId = `combobox-warn-text-${comboBoxInstanceId}`;
  const invalidTextId = `combobox-invalid-text-${comboBoxInstanceId}`;
  const helperClasses = cx__default["default"](`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const wrapperClasses = cx__default["default"](`${prefix}--list-box__wrapper`, [containerClassName, {
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--fluid--focus`]: isFluid && isFocused,
    [`${prefix}--list-box__wrapper--slug`]: slug
  }]);
  const inputClasses = cx__default["default"](`${prefix}--text-input`, {
    [`${prefix}--text-input--empty`]: !inputValue,
    [`${prefix}--combo-box--input--focus`]: isFocused && !isFluid
  });

  // needs to be Capitalized for react to render it correctly
  const ItemToElement = itemToElement;

  // Slug is always size `mini`
  let normalizedSlug;
  if (slug && slug['type']?.displayName === 'Slug') {
    normalizedSlug = /*#__PURE__*/React__default["default"].cloneElement(slug, {
      size: 'mini'
    });
  }
  const {
    getInputProps,
    getItemProps,
    getLabelProps,
    getMenuProps,
    getToggleButtonProps,
    isOpen,
    highlightedIndex,
    selectItem,
    selectedItem,
    toggleMenu,
    setHighlightedIndex
  } = Downshift.useCombobox({
    ...downshiftProps,
    items,
    inputValue: inputValue,
    itemToString: item => {
      return itemToString(item);
    },
    onInputValueChange(_ref3) {
      let {
        inputValue
      } = _ref3;
      setInputValue(inputValue || '');
      setHighlightedIndex(indexToHighlight(inputValue));
    },
    onSelectedItemChange(_ref4) {
      let {
        selectedItem
      } = _ref4;
      onChange({
        selectedItem
      });
    },
    initialSelectedItem: initialSelectedItem,
    inputId: id,
    stateReducer,
    isItemDisabled(item, _index) {
      return item.disabled;
    }
  });
  const buttonProps = getToggleButtonProps({
    disabled: disabled || readOnly,
    onClick: handleToggleClick(isOpen),
    // When we moved the "root node" of Downshift to the <input> for
    // ARIA 1.2 compliance, we unfortunately hit this branch for the
    // "mouseup" event that downshift listens to:
    // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
    //
    // As a result, it will reset the state of the component and so we
    // stop the event from propagating to prevent this if the menu is already open.
    // This allows the toggleMenu behavior for the toggleButton to correctly open and
    // close the menu.
    onMouseUp(event) {
      if (isOpen) {
        event.stopPropagation();
      }
    }
  });
  const handleFocus = evt => {
    setIsFocused(evt.type === 'focus');
  };
  const readOnlyEventHandlers = readOnly ? {
    onKeyDown: evt => {
      // This prevents the select from opening for the above keys
      if (evt.key !== 'Tab') {
        evt.preventDefault();
      }
    }
  } : {};

  // The input should be described by the appropriate message text id
  // when both the message is supplied *and* when the component is in
  // the matching state (invalid, warn, etc).
  const ariaDescribedBy = invalid && invalidText && invalidTextId || warn && warnText && warnTextId || helperText && !isFluid && helperTextId || undefined;
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: wrapperClasses
  }, titleText && /*#__PURE__*/React__default["default"].createElement(Text.Text, _rollupPluginBabelHelpers["extends"]({
    as: "label",
    className: titleClasses
  }, getLabelProps()), titleText), /*#__PURE__*/React__default["default"].createElement(index["default"], {
    onFocus: handleFocus,
    onBlur: handleFocus,
    className: className,
    disabled: disabled,
    invalid: invalid,
    invalidText: invalidText,
    invalidTextId: invalidTextId,
    isOpen: isOpen,
    light: light,
    size: size,
    warn: warn,
    warnText: warnText,
    warnTextId: warnTextId
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: `${prefix}--list-box__field`
  }, /*#__PURE__*/React__default["default"].createElement("input", _rollupPluginBabelHelpers["extends"]({
    disabled: disabled,
    className: inputClasses,
    type: "text",
    tabIndex: 0,
    "aria-haspopup": "listbox",
    "aria-owns": getMenuProps().id,
    title: textInput?.current?.value
  }, getInputProps({
    placeholder,
    ref: {
      ...mergeRefs["default"](textInput, ref)
    },
    onKeyDown: event => {
      if (match.match(event, keys.Space)) {
        event.stopPropagation();
      }
      if (match.match(event, keys.Enter) && (!inputValue || allowCustomValue)) {
        toggleMenu();
        if (highlightedIndex !== -1) {
          selectItem(items[highlightedIndex]);
        }
        event.preventDownshiftDefault = true;
        event?.persist?.();
      }
      if (match.match(event, keys.Escape) && inputValue) {
        if (event.target === textInput.current && isOpen) {
          toggleMenu();
          event.preventDownshiftDefault = true;
          event?.persist?.();
        }
      }
      if (match.match(event, keys.Home) && event.code !== 'Numpad7') {
        event.target.setSelectionRange(0, 0);
      }
      if (match.match(event, keys.End) && event.code !== 'Numpad1') {
        event.target.setSelectionRange(event.target.value.length, event.target.value.length);
      }
      if (event.altKey && event.key == 'ArrowDown') {
        event.preventDownshiftDefault = true;
        if (!isOpen) {
          toggleMenu();
        }
      }
      if (event.altKey && event.key == 'ArrowUp') {
        event.preventDownshiftDefault = true;
        if (isOpen) {
          toggleMenu();
        }
      }
    }
  }), rest, readOnlyEventHandlers, {
    readOnly: readOnly,
    "aria-describedby": ariaDescribedBy
  })), invalid && /*#__PURE__*/React__default["default"].createElement(iconsReact.WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && /*#__PURE__*/React__default["default"].createElement(iconsReact.WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), inputValue && /*#__PURE__*/React__default["default"].createElement(ListBoxSelection["default"], {
    clearSelection: () => {
      selectItem(null);
    },
    translateWithId: translateWithId,
    disabled: disabled || readOnly,
    onClearSelection: handleSelectionClear,
    selectionCount: 0
  }), /*#__PURE__*/React__default["default"].createElement(ListBoxTrigger["default"], _rollupPluginBabelHelpers["extends"]({}, buttonProps, {
    // @ts-expect-error
    isOpen: isOpen,
    translateWithId: translateWithId
  }))), normalizedSlug, /*#__PURE__*/React__default["default"].createElement(index["default"].Menu, getMenuProps({
    'aria-label': deprecatedAriaLabel || ariaLabel
  }), isOpen ? filterItems(items, itemToString, inputValue).map((item, index$1) => {
    const isObject = item !== null && typeof item === 'object';
    const title = isObject && 'text' in item && itemToElement ? item.text?.toString() : itemToString(item);
    const itemProps = getItemProps({
      item,
      index: index$1
    });

    // The initial implementation using <Downshift> would place the disabled attribute
    // on disabled menu items. Conversely, useCombobox places aria-disabled instead.
    // To avoid any potential breaking changes, we avoid placing aria-disabled and
    // instead match the old behavior of placing the disabled attribute.
    const disabled = itemProps['aria-disabled'];
    const {
      'aria-disabled': unusedAriaDisabled,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...modifiedItemProps
    } = itemProps;
    return /*#__PURE__*/React__default["default"].createElement(index["default"].MenuItem, _rollupPluginBabelHelpers["extends"]({
      key: itemProps.id,
      isActive: selectedItem === item,
      isHighlighted: highlightedIndex === index$1,
      title: title,
      disabled: disabled
    }, modifiedItemProps), ItemToElement ? /*#__PURE__*/React__default["default"].createElement(ItemToElement, _rollupPluginBabelHelpers["extends"]({
      key: itemProps.id
    }, item)) : itemToString(item), selectedItem === item && /*#__PURE__*/React__default["default"].createElement(iconsReact.Checkmark, {
      className: `${prefix}--list-box__menu-item__selected-icon`
    }));
  }) : null)), helperText && !invalid && !warn && !isFluid && /*#__PURE__*/React__default["default"].createElement(Text.Text, {
    as: "div",
    id: helperTextId,
    className: helperClasses
  }, helperText));
});
ComboBox.displayName = 'ComboBox';
ComboBox.propTypes = {
  /**
   * Specify whether or not the ComboBox should allow a value that is
   * not in the list to be entered in the input
   */
  allowCustomValue: PropTypes__default["default"].bool,
  /**
   * 'aria-label' of the ListBox component.
   * Specify a label to be read by screen readers on the container node
   */
  ['aria-label']: PropTypes__default["default"].string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   * 'aria-label' of the ListBox component.
   */
  ariaLabel: deprecate["default"](PropTypes__default["default"].string, 'This prop syntax has been deprecated. Please use the new `aria-label`.'),
  /**
   * An optional className to add to the container node
   */
  className: PropTypes__default["default"].string,
  /**
   * Specify the direction of the combobox dropdown. Can be either top or bottom.
   */
  direction: PropTypes__default["default"].oneOf(['top', 'bottom']),
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: PropTypes__default["default"].bool,
  /**
   * Additional props passed to Downshift
   */
  downshiftProps: PropTypes__default["default"].object,
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: PropTypes__default["default"].node,
  /**
   * Specify a custom `id` for the input
   */
  id: PropTypes__default["default"].string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].string, PropTypes__default["default"].number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: PropTypes__default["default"].bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: PropTypes__default["default"].node,
  /**
   * Optional function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: PropTypes__default["default"].func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list
   */
  itemToString: PropTypes__default["default"].func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: PropTypes__default["default"].array.isRequired,
  /**
   * should use "light theme" (white background)?
   */
  light: deprecate["default"](PropTypes__default["default"].bool, 'The `light` prop for `Combobox` has ' + 'been deprecated in favor of the new `Layer` component. It will be removed in the next major release.'),
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component when a specific dropdown item is selected.
   * `({ selectedItem }) => void`
   * @param {{ selectedItem }}
   */
  onChange: PropTypes__default["default"].func.isRequired,
  /**
   * Callback function to notify consumer when the text input changes.
   * This provides support to change available items based on the text.
   * `(inputText) => void`
   * @param {string} inputText
   */
  onInputChange: PropTypes__default["default"].func,
  /**
   * Callback function that fires when the combobox menu toggle is clicked
   * `(evt) => void`
   * @param {MouseEvent} event
   */
  onToggleClick: PropTypes__default["default"].func,
  /**
   * Used to provide a placeholder text node before a user enters any input.
   * This is only present if the control has no items selected
   */
  placeholder: PropTypes__default["default"].string,
  /**
   * Is the ComboBox readonly?
   */
  readOnly: PropTypes__default["default"].bool,
  /**
   * For full control of the selection
   */
  selectedItem: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].string, PropTypes__default["default"].number]),
  /**
   * Specify your own filtering logic by passing in a `shouldFilterItem`
   * function that takes in the current input and an item and passes back
   * whether or not the item should be filtered.
   */
  shouldFilterItem: PropTypes__default["default"].func,
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxPropTypes.ListBoxSize,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `ComboBox` component
   */
  slug: PropTypes__default["default"].node,
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * combobox via ARIA attributes.
   */
  titleText: PropTypes__default["default"].node,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: PropTypes__default["default"].func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: PropTypes__default["default"].bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: PropTypes__default["default"].node
};

exports["default"] = ComboBox;
