/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');
var cx = require('classnames');
var PropTypes = require('prop-types');
var React = require('react');
var iconsReact = require('@carbon/icons-react');
var useControllableState = require('../../internal/useControllableState.js');
var useMergedRefs = require('../../internal/useMergedRefs.js');
var usePrefix = require('../../internal/usePrefix.js');
var warning = require('../../internal/warning.js');
var Menu = require('./Menu.js');
var MenuContext = require('./MenuContext.js');
require('../Text/index.js');
var useLayoutDirection = require('../LayoutDirection/useLayoutDirection.js');
var Text = require('../Text/Text.js');
var match = require('../../internal/keyboard/match.js');
var keys = require('../../internal/keyboard/keys.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var _CaretLeft, _CaretRight;
const hoverIntentDelay = 150; // in ms
const leaveIntentDelay = 300; // in ms

const MenuItem = /*#__PURE__*/React.forwardRef(function MenuItem(_ref, forwardRef) {
  let {
    children,
    className,
    disabled,
    kind = 'default',
    label,
    onClick,
    renderIcon: IconElement,
    shortcut,
    ...rest
  } = _ref;
  const prefix = usePrefix.usePrefix();
  const context = React.useContext(MenuContext.MenuContext);
  const menuItem = React.useRef(null);
  const ref = useMergedRefs.useMergedRefs([forwardRef, menuItem]);
  const [boundaries, setBoundaries] = React.useState({
    x: -1,
    y: -1
  });
  const [rtl, setRtl] = React.useState(false);
  const hasChildren = Boolean(children);
  const [submenuOpen, setSubmenuOpen] = React.useState(false);
  const hoverIntentTimeout = React.useRef(null);
  const leaveIntentTimeout = React.useRef(null);
  const isDisabled = disabled && !hasChildren;
  const isDanger = kind === 'danger' && !hasChildren;
  function registerItem() {
    context.dispatch({
      type: 'registerItem',
      payload: {
        ref: menuItem,
        disabled: Boolean(disabled)
      }
    });
  }
  function openSubmenu() {
    if (!menuItem.current) {
      return;
    }
    const {
      x,
      y,
      width,
      height
    } = menuItem.current.getBoundingClientRect();
    if (rtl) {
      setBoundaries({
        x: [-x, x - width],
        y: [y, y + height]
      });
    } else {
      setBoundaries({
        x: [x, x + width],
        y: [y, y + height]
      });
    }
    setSubmenuOpen(true);
  }
  function closeSubmenu() {
    setSubmenuOpen(false);
    setBoundaries({
      x: -1,
      y: -1
    });
  }
  function handleClick(e) {
    if (!isDisabled) {
      if (hasChildren) {
        openSubmenu();
      } else {
        context.state.requestCloseRoot(e);
        if (onClick) {
          onClick(e);
        }
      }
    }
  }
  function handleMouseEnter() {
    if (leaveIntentTimeout.current) {
      // When mouse reenters before closing keep sub menu open
      clearTimeout(leaveIntentTimeout.current);
      leaveIntentTimeout.current = null;
    }
    hoverIntentTimeout.current = setTimeout(() => {
      openSubmenu();
    }, hoverIntentDelay);
  }
  function handleMouseLeave() {
    if (hoverIntentTimeout.current) {
      clearTimeout(hoverIntentTimeout.current);
      // Avoid closing the sub menu as soon as mouse leaves
      // prevents accidental closure due to scroll bar
      leaveIntentTimeout.current = setTimeout(() => {
        closeSubmenu();
        menuItem.current?.focus();
      }, leaveIntentDelay);
    }
  }
  function handleKeyDown(e) {
    if (hasChildren && match.match(e, keys.ArrowRight)) {
      openSubmenu();
      e.stopPropagation();
    }
    if (match.match(e, keys.Enter) || match.match(e, keys.Space)) {
      handleClick(e);
    }
    if (rest.onKeyDown) {
      rest.onKeyDown(e);
    }
  }
  const classNames = cx__default["default"](className, `${prefix}--menu-item`, {
    [`${prefix}--menu-item--disabled`]: isDisabled,
    [`${prefix}--menu-item--danger`]: isDanger
  });

  // on first render, register this menuitem in the context's state
  // (used for keyboard navigation)
  React.useEffect(() => {
    registerItem();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Set RTL based on the document direction or `LayoutDirection`
  const {
    direction
  } = useLayoutDirection.useLayoutDirection();
  React.useEffect(() => {
    if (document?.dir === 'rtl' || direction === 'rtl') {
      setRtl(true);
    } else {
      setRtl(false);
    }
  }, [direction]);
  const iconsAllowed = context.state.mode === 'basic' || rest.role === 'menuitemcheckbox' || rest.role === 'menuitemradio';
  React.useEffect(() => {
    if (iconsAllowed && IconElement && !context.state.hasIcons) {
      // @ts-ignore - TODO: Should we be passing payload?
      context.dispatch({
        type: 'enableIcons'
      });
    }
  }, [iconsAllowed, IconElement, context.state.hasIcons, context]);
  return /*#__PURE__*/React__default["default"].createElement("li", _rollupPluginBabelHelpers["extends"]({
    role: "menuitem"
  }, rest, {
    ref: ref,
    className: classNames,
    tabIndex: -1,
    "aria-disabled": isDisabled ?? undefined,
    "aria-haspopup": hasChildren ?? undefined,
    "aria-expanded": hasChildren ? submenuOpen : undefined,
    onClick: handleClick,
    onMouseEnter: hasChildren ? handleMouseEnter : undefined,
    onMouseLeave: hasChildren ? handleMouseLeave : undefined,
    onKeyDown: handleKeyDown
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: `${prefix}--menu-item__icon`
  }, iconsAllowed && IconElement && /*#__PURE__*/React__default["default"].createElement(IconElement, null)), /*#__PURE__*/React__default["default"].createElement(Text.Text, {
    as: "div",
    className: `${prefix}--menu-item__label`,
    title: label
  }, label), shortcut && !hasChildren && /*#__PURE__*/React__default["default"].createElement("div", {
    className: `${prefix}--menu-item__shortcut`
  }, shortcut), hasChildren && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
    className: `${prefix}--menu-item__shortcut`
  }, rtl ? _CaretLeft || (_CaretLeft = /*#__PURE__*/React__default["default"].createElement(iconsReact.CaretLeft, null)) : _CaretRight || (_CaretRight = /*#__PURE__*/React__default["default"].createElement(iconsReact.CaretRight, null))), /*#__PURE__*/React__default["default"].createElement(Menu.Menu, {
    label: label,
    open: submenuOpen,
    onClose: () => {
      closeSubmenu();
      menuItem.current?.focus();
    },
    x: boundaries.x,
    y: boundaries.y
  }, children)));
});
MenuItem.propTypes = {
  /**
   * Optionally provide another Menu to create a submenu. props.children can't be used to specify the content of the MenuItem itself. Use props.label instead.
   */
  children: PropTypes__default["default"].node,
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,
  /**
   * Specify whether the MenuItem is disabled or not.
   */
  disabled: PropTypes__default["default"].bool,
  /**
   * Specify the kind of the MenuItem.
   */
  kind: PropTypes__default["default"].oneOf(['default', 'danger']),
  /**
   * A required label titling the MenuItem. Will be rendered as its text content.
   */
  label: PropTypes__default["default"].string.isRequired,
  /**
   * Provide an optional function to be called when the MenuItem is clicked.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onClick: PropTypes__default["default"].func,
  /**
   * Only applicable if the parent menu is in `basic` mode. Sets the menu item's icon.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
  /**
   * Provide a shortcut for the action of this MenuItem. Note that the component will only render it as a hint but not actually register the shortcut.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  shortcut: PropTypes__default["default"].string
};
const MenuItemSelectable = /*#__PURE__*/React.forwardRef(function MenuItemSelectable(_ref2, forwardRef) {
  let {
    className,
    defaultSelected,
    label,
    onChange,
    selected,
    ...rest
  } = _ref2;
  const prefix = usePrefix.usePrefix();
  const context = React.useContext(MenuContext.MenuContext);
  if (context.state.mode === 'basic') {
    process.env.NODE_ENV !== "production" ? warning.warning(false, 'MenuItemSelectable is not supported when the menu is in "basic" mode.') : void 0;
  }
  const [checked, setChecked] = useControllableState.useControllableState({
    value: selected,
    onChange,
    defaultValue: defaultSelected ?? false
  });
  function handleClick(e) {
    setChecked(!checked);
    if (onChange) {
      onChange(e);
    }
  }
  React.useEffect(() => {
    if (!context.state.hasIcons) {
      // @ts-ignore - TODO: Should we be passing payload?
      context.dispatch({
        type: 'enableIcons'
      });
    }
  }, [context.state.hasIcons, context]);
  const classNames = cx__default["default"](className, `${prefix}--menu-item-selectable--selected`);
  return /*#__PURE__*/React__default["default"].createElement(MenuItem, _rollupPluginBabelHelpers["extends"]({}, rest, {
    ref: forwardRef,
    label: label,
    className: classNames,
    role: "menuitemcheckbox",
    "aria-checked": checked,
    renderIcon: checked ? iconsReact.Checkmark : undefined,
    onClick: handleClick
  }));
});
MenuItemSelectable.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,
  /**
   * Specify whether the option should be selected by default.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  defaultSelected: PropTypes__default["default"].bool,
  /**
   * A required label titling this option.
   */
  label: PropTypes__default["default"].string.isRequired,
  /**
   * Provide an optional function to be called when the selection state changes.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onChange: PropTypes__default["default"].func,
  /**
   * Pass a bool to props.selected to control the state of this option.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  selected: PropTypes__default["default"].bool
};
const MenuItemGroup = /*#__PURE__*/React.forwardRef(function MenuItemGroup(_ref3, forwardRef) {
  let {
    children,
    className,
    label,
    ...rest
  } = _ref3;
  const prefix = usePrefix.usePrefix();
  const classNames = cx__default["default"](className, `${prefix}--menu-item-group`);
  return /*#__PURE__*/React__default["default"].createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef
  }, /*#__PURE__*/React__default["default"].createElement("ul", _rollupPluginBabelHelpers["extends"]({}, rest, {
    role: "group",
    "aria-label": label
  }), children));
});
MenuItemGroup.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this group.
   */
  children: PropTypes__default["default"].node,
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,
  /**
   * A required label titling this group.
   */
  label: PropTypes__default["default"].string.isRequired
};
const defaultItemToString = item => item.toString();
const MenuItemRadioGroup = /*#__PURE__*/React.forwardRef(function MenuItemRadioGroup(_ref4, forwardRef) {
  let {
    className,
    defaultSelectedItem,
    items,
    itemToString = defaultItemToString,
    label,
    onChange,
    selectedItem,
    ...rest
  } = _ref4;
  const prefix = usePrefix.usePrefix();
  const context = React.useContext(MenuContext.MenuContext);
  if (context.state.mode === 'basic') {
    process.env.NODE_ENV !== "production" ? warning.warning(false, 'MenuItemRadioGroup is not supported when the menu is in "basic" mode.') : void 0;
  }
  const [selection, setSelection] = useControllableState.useControllableState({
    value: selectedItem,
    onChange,
    defaultValue: defaultSelectedItem
  });
  function handleClick(item, e) {
    setSelection(item);
    if (onChange) {
      onChange(e);
    }
  }
  React.useEffect(() => {
    if (!context.state.hasIcons) {
      // @ts-ignore - TODO: Should we be passing payload?
      context.dispatch({
        type: 'enableIcons'
      });
    }
  }, [context.state.hasIcons, context]);
  const classNames = cx__default["default"](className, `${prefix}--menu-item-radio-group`);
  return /*#__PURE__*/React__default["default"].createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef
  }, /*#__PURE__*/React__default["default"].createElement("ul", _rollupPluginBabelHelpers["extends"]({}, rest, {
    role: "group",
    "aria-label": label
  }), items.map((item, i) => /*#__PURE__*/React__default["default"].createElement(MenuItem, {
    key: i,
    label: itemToString(item),
    role: "menuitemradio",
    "aria-checked": item === selection,
    renderIcon: item === selection ? iconsReact.Checkmark : undefined,
    onClick: e => {
      handleClick(item, e);
    }
  }))));
});
MenuItemRadioGroup.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,
  /**
   * Specify the default selected item. Must match the type of props.items.
   */
  defaultSelectedItem: PropTypes__default["default"].any,
  /**
   * Provide a function to convert an item to the string that will be rendered. Defaults to item.toString().
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  itemToString: PropTypes__default["default"].func,
  /**
   * Provide the options for this radio group. Can be of any type, as long as you provide an appropriate props.itemToString function.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  items: PropTypes__default["default"].array,
  /**
   * A required label titling this radio group.
   */
  label: PropTypes__default["default"].string.isRequired,
  /**
   * Provide an optional function to be called when the selection changes.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onChange: PropTypes__default["default"].func,
  /**
   * Provide props.selectedItem to control the state of this radio group. Must match the type of props.items.
   */
  selectedItem: PropTypes__default["default"].any
};
const MenuItemDivider = /*#__PURE__*/React.forwardRef(function MenuItemDivider(_ref5, forwardRef) {
  let {
    className,
    ...rest
  } = _ref5;
  const prefix = usePrefix.usePrefix();
  const classNames = cx__default["default"](className, `${prefix}--menu-item-divider`);
  return /*#__PURE__*/React__default["default"].createElement("li", _rollupPluginBabelHelpers["extends"]({}, rest, {
    className: classNames,
    role: "separator",
    ref: forwardRef
  }));
});
MenuItemDivider.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string
};

exports.MenuItem = MenuItem;
exports.MenuItemDivider = MenuItemDivider;
exports.MenuItemGroup = MenuItemGroup;
exports.MenuItemRadioGroup = MenuItemRadioGroup;
exports.MenuItemSelectable = MenuItemSelectable;
